\doxysection{C\+:/\+Users/joaop/\+Desktop/\+DA\+\_\+proj1/\+Individual-\/\+Route-\/\+Planning-\/\+Tool/classes/\+Planning.h File Reference}
\hypertarget{_planning_8h}{}\label{_planning_8h}\index{C:/Users/joaop/Desktop/DA\_proj1/Individual-\/Route-\/Planning-\/Tool/classes/Planning.h@{C:/Users/joaop/Desktop/DA\_proj1/Individual-\/Route-\/Planning-\/Tool/classes/Planning.h}}
{\ttfamily \#include "{}data\+\_\+structures/\+Urban\+Map.\+h"{}}\newline
{\ttfamily \#include "{}data\+\_\+structures/cases.\+h"{}}\newline
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{_planning_8h_ae2e0e759108ef41e869dd46f4742151c}{dijkstra}} (\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}g, const int \&origin)
\begin{DoxyCompactList}\small\item\em Implements Dijkstra\textquotesingle{}s shortest path algorithm on an \doxylink{class_urban_map}{Urban\+Map}. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \mbox{\hyperlink{_planning_8h_a2d0b80f4eddcbcf2ab5534fa29bba6d5}{get\+Path}} (\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}g, const std\+::string \&origin, const std\+::string \&dest)
\begin{DoxyCompactList}\small\item\em Retrieves the shortest path from an origin to a destination in an \doxylink{class_urban_map}{Urban\+Map}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_planning_8h_a64a02bcebb9a65eec66909ee45245349}{case1}} (\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}urban\+\_\+map)
\begin{DoxyCompactList}\small\item\em computes the top-\/2 best routes to take from the source node to the destination on a specific mode. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_planning_8h_a2c0333fc34fc57bd91bd6f078843dd2f}{case2}} (\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}urban\+\_\+map)
\begin{DoxyCompactList}\small\item\em Computes the best route that avoids certain segments, locations(vertex) and may include a certain node in the path. Each node is deactivated using a boolean value {\itshape is\+Visited} and if that value is true the dijkstra won\textquotesingle{}t include that node in the path. Same thing goes for the segments that also use a boolean value {\itshape is\+Selected}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{_planning_8h_aa7f4a2a19efe9c5718b1fe4164e4fe62}{case3}} (\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}urban\+\_\+map)
\begin{DoxyCompactList}\small\item\em This function combines both walking and driving. First we do a dijkstra from the source to a node in the parking\+Nodes vector of the graph, wich has all the ids of the nodes that have parking. Then we do a dijkstra from that parking node to the destination using walking distances, making sure that the resulting walking time does not exceed the maximum. We do this for every parking node and we get the best overall time. In case two paths have the same total time, we select the one with more walking time to be more economic. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{_planning_8h_a64a02bcebb9a65eec66909ee45245349}\index{Planning.h@{Planning.h}!case1@{case1}}
\index{case1@{case1}!Planning.h@{Planning.h}}
\doxysubsubsection{\texorpdfstring{case1()}{case1()}}
{\footnotesize\ttfamily \label{_planning_8h_a64a02bcebb9a65eec66909ee45245349} 
void case1 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}}]{urban\+\_\+map}{}\end{DoxyParamCaption})}



computes the top-\/2 best routes to take from the source node to the destination on a specific mode. 

This function uses two dijkstras, the first one to compute the best route, and the second one executes after the intermediary nodes of the first were labelled, so that it does not include them in the dijkstra.


\begin{DoxyParams}{Parameters}
{\em urban\+\_\+map} & is a pointer to the \doxylink{class_urban_map}{Urban\+Map} graph containing locations and connections.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function outputs to an output1.\+txt where the results can be seen.
\end{DoxyNote}
@complexity Does two dijkstras each one with complexity {\bfseries{O((V+E)logV)}} and also does two \doxylink{_planning_8cpp_a2d0b80f4eddcbcf2ab5534fa29bba6d5}{get\+Path()} with complexity {\bfseries{O(\+V)}} This results in a final complexity of {\bfseries{O((V+E)logV)}} \Hypertarget{_planning_8h_a2c0333fc34fc57bd91bd6f078843dd2f}\index{Planning.h@{Planning.h}!case2@{case2}}
\index{case2@{case2}!Planning.h@{Planning.h}}
\doxysubsubsection{\texorpdfstring{case2()}{case2()}}
{\footnotesize\ttfamily \label{_planning_8h_a2c0333fc34fc57bd91bd6f078843dd2f} 
void case2 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}}]{urban\+\_\+map}{}\end{DoxyParamCaption})}



Computes the best route that avoids certain segments, locations(vertex) and may include a certain node in the path. Each node is deactivated using a boolean value {\itshape is\+Visited} and if that value is true the dijkstra won\textquotesingle{}t include that node in the path. Same thing goes for the segments that also use a boolean value {\itshape is\+Selected}. 

This function uses one dijkstra if there is no Node to include, or uses two dijkstras, one from the source to compute the distance to the node to include, and another starting from the included node to the destination.


\begin{DoxyParams}{Parameters}
{\em urban\+\_\+map} & is a pointer to the \doxylink{class_urban_map}{Urban\+Map} graph containing locations and connections.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function outputs to an output1.\+txt where the results can be seen.
\end{DoxyNote}
@complexity Does two dijkstras each one with complexity {\bfseries{O((V+E)logV)}} or does only one dijkstra with the same complexity, and also uses function \doxylink{_planning_8cpp_a2d0b80f4eddcbcf2ab5534fa29bba6d5}{get\+Path()} with complexity {\bfseries{O(\+V)}} To deactivate the nodes it takes a traversal on a vector with ids {\bfseries{O(n)}} To deactivate the segments it takes a traversal on a vector with pairs of ids and for the origin and destination it finds in the adjacency list the other node of the segment, so the complexity is {\bfseries{O(n\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+E\texorpdfstring{$\vert$}{|})}} This results in a final complexity of {\bfseries{O((V+E)logV), because the dijkstra dominates the complexity}} \Hypertarget{_planning_8h_aa7f4a2a19efe9c5718b1fe4164e4fe62}\index{Planning.h@{Planning.h}!case3@{case3}}
\index{case3@{case3}!Planning.h@{Planning.h}}
\doxysubsubsection{\texorpdfstring{case3()}{case3()}}
{\footnotesize\ttfamily \label{_planning_8h_aa7f4a2a19efe9c5718b1fe4164e4fe62} 
void case3 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}}]{urban\+\_\+map}{}\end{DoxyParamCaption})}



This function combines both walking and driving. First we do a dijkstra from the source to a node in the parking\+Nodes vector of the graph, wich has all the ids of the nodes that have parking. Then we do a dijkstra from that parking node to the destination using walking distances, making sure that the resulting walking time does not exceed the maximum. We do this for every parking node and we get the best overall time. In case two paths have the same total time, we select the one with more walking time to be more economic. 


\begin{DoxyParams}{Parameters}
{\em urban\+\_\+map} & is a pointer to the \doxylink{class_urban_map}{Urban\+Map} graph containing locations and connections.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
This function outputs to an output1.\+txt where the results can be seen.
\end{DoxyNote}
@complexity Does two dijkstras each one with complexity {\bfseries{O((V+E)logV)}} for each node in the parking\+Nodes vector of the graph, this results in {\bfseries{O(V(V+E)logV)}}, and also uses function \doxylink{_planning_8cpp_a2d0b80f4eddcbcf2ab5534fa29bba6d5}{get\+Path()} with complexity {\bfseries{O(\+V)}} To deactivate the nodes it takes a traversal on a vector with ids {\bfseries{O(n)}} To deactivate the segments it takes a traversal on a vector with pairs of ids and for the origin and destination it finds in the adjacency list the other node of the segment, so the complexity is {\bfseries{O(n\texorpdfstring{$\ast$}{*}\texorpdfstring{$\vert$}{|}\+E\texorpdfstring{$\vert$}{|})}} This results in a final complexity of {\bfseries{O(V(V+E)logV)}}

When it comes to spacial complexity, since we compute each route to the parking node and then to the destination and we compute the path and save it on a vector, this results in @complexity {\bfseries{O(n)}}. \Hypertarget{_planning_8h_ae2e0e759108ef41e869dd46f4742151c}\index{Planning.h@{Planning.h}!dijkstra@{dijkstra}}
\index{dijkstra@{dijkstra}!Planning.h@{Planning.h}}
\doxysubsubsection{\texorpdfstring{dijkstra()}{dijkstra()}}
{\footnotesize\ttfamily \label{_planning_8h_ae2e0e759108ef41e869dd46f4742151c} 
void dijkstra (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}}]{g}{, }\item[{const int \&}]{origin}{}\end{DoxyParamCaption})}



Implements Dijkstra\textquotesingle{}s shortest path algorithm on an \doxylink{class_urban_map}{Urban\+Map}. 

This function initializes all locations with a maximum distance and then applies Dijkstra\textquotesingle{}s algorithm using a priority queue to find the shortest paths from the given origin.


\begin{DoxyParams}{Parameters}
{\em g} & Pointer to the \doxylink{class_urban_map}{Urban\+Map} graph containing locations and connections. \\
\hline
{\em origin} & The index (1-\/based) of the starting location for Dijkstra\textquotesingle{}s algorithm.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The algorithm uses a mutable priority queue to efficiently retrieve the vertex with the minimum distance, ensuring an optimal performance.
\end{DoxyNote}
@complexity The time complexity is {\bfseries{O((V + E) log V)}}, where\+:
\begin{DoxyItemize}
\item V is the number of locations (vertices) in the \doxylink{class_urban_map}{Urban\+Map}.
\item E is the number of connections (edges) between locations.
\item The {\ttfamily extract\+Min()} operation runs in {\bfseries{O(log V)}}.
\item The relaxation step is performed {\bfseries{O(\+E)}} times, each taking {\bfseries{O(log V)}} in the worst case. 
\end{DoxyItemize}\Hypertarget{_planning_8h_a2d0b80f4eddcbcf2ab5534fa29bba6d5}\index{Planning.h@{Planning.h}!getPath@{getPath}}
\index{getPath@{getPath}!Planning.h@{Planning.h}}
\doxysubsubsection{\texorpdfstring{getPath()}{getPath()}}
{\footnotesize\ttfamily \label{_planning_8h_a2d0b80f4eddcbcf2ab5534fa29bba6d5} 
std\+::vector$<$ int $>$ get\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_urban_map}{Urban\+Map}}$<$ std\+::string $>$ \texorpdfstring{$\ast$}{*}}]{g}{, }\item[{const std\+::string \&}]{origin}{, }\item[{const std\+::string \&}]{dest}{}\end{DoxyParamCaption})}



Retrieves the shortest path from an origin to a destination in an \doxylink{class_urban_map}{Urban\+Map}. 

This function reconstructs the shortest path by backtracking from the destination to the origin using the {\ttfamily \doxylink{_planning_8cpp_a2d0b80f4eddcbcf2ab5534fa29bba6d5}{get\+Path()}} pointers stored during the execution of Dijkstra’s algorithm.


\begin{DoxyParams}{Parameters}
{\em g} & Pointer to the \doxylink{class_urban_map}{Urban\+Map} graph containing locations and connections. \\
\hline
{\em origin} & The name of the starting location. \\
\hline
{\em dest} & The name of the destination location. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector of integers representing the sequence of location IDs along the shortest path.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The function assumes that Dijkstra\textquotesingle{}s algorithm has already been executed, and the {\ttfamily \doxylink{_planning_8cpp_a2d0b80f4eddcbcf2ab5534fa29bba6d5}{get\+Path()}} pointers are correctly set for each location.
\end{DoxyNote}
@complexity The time complexity is {\bfseries{O(\+V)}} in the worst case, where\+:
\begin{DoxyItemize}
\item Finding the destination vertex\+: {\bfseries{O(1)}} (assuming efficient hashing or indexing).
\item Backtracking through the path\+: {\bfseries{O(\+V)}} (in the worst case of a long path).
\item Reversing the result vector\+: {\bfseries{O(\+V)}}.
\item Overall complexity\+: {\bfseries{O(\+V)}}. 
\end{DoxyItemize}