<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Individual-Route-Planning-Tool: C:/Users/joaop/Desktop/DA_proj1/Individual-Route-Planning-Tool/classes/Planning.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Individual-Route-Planning-Tool
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('_planning_8h.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Planning.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="_urban_map_8h_source.html">data_structures/UrbanMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cases_8h_source.html">data_structures/cases.h</a>&quot;</code><br />
</div>
<p><a href="_planning_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae2e0e759108ef41e869dd46f4742151c" id="r_ae2e0e759108ef41e869dd46f4742151c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2e0e759108ef41e869dd46f4742151c">dijkstra</a> (<a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *g, const int &amp;origin)</td></tr>
<tr class="memdesc:ae2e0e759108ef41e869dd46f4742151c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Dijkstra's shortest path algorithm on an <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a>.  <br /></td></tr>
<tr class="separator:ae2e0e759108ef41e869dd46f4742151c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0b80f4eddcbcf2ab5534fa29bba6d5" id="r_a2d0b80f4eddcbcf2ab5534fa29bba6d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d0b80f4eddcbcf2ab5534fa29bba6d5">getPath</a> (<a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *g, const std::string &amp;origin, const std::string &amp;dest)</td></tr>
<tr class="memdesc:a2d0b80f4eddcbcf2ab5534fa29bba6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the shortest path from an origin to a destination in an <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a>.  <br /></td></tr>
<tr class="separator:a2d0b80f4eddcbcf2ab5534fa29bba6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a02bcebb9a65eec66909ee45245349" id="r_a64a02bcebb9a65eec66909ee45245349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64a02bcebb9a65eec66909ee45245349">case1</a> (<a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *urban_map)</td></tr>
<tr class="memdesc:a64a02bcebb9a65eec66909ee45245349"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the top-2 best routes to take from the source node to the destination on a specific mode  <br /></td></tr>
<tr class="separator:a64a02bcebb9a65eec66909ee45245349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0333fc34fc57bd91bd6f078843dd2f" id="r_a2c0333fc34fc57bd91bd6f078843dd2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c0333fc34fc57bd91bd6f078843dd2f">case2</a> (<a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *urban_map)</td></tr>
<tr class="memdesc:a2c0333fc34fc57bd91bd6f078843dd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the best route that avoids certain segments, locations(vertex) and may include a certain node in the path. Each node is deactivated using a boolean value <em>isVisited</em> and if that value is true the dijkstra won't include that node in the path. Same thing goes for the segments that also use a boolean value <em>isSelected</em>.  <br /></td></tr>
<tr class="separator:a2c0333fc34fc57bd91bd6f078843dd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f4a2a19efe9c5718b1fe4164e4fe62" id="r_aa7f4a2a19efe9c5718b1fe4164e4fe62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7f4a2a19efe9c5718b1fe4164e4fe62">case3</a> (<a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *urban_map)</td></tr>
<tr class="memdesc:aa7f4a2a19efe9c5718b1fe4164e4fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function combines both walking and driving. First we do a dijkstra from the source to a node in the parkingNodes vector of the graph, wich has all the ids of the nodes that have parking. Then we do a dijkstra from that parking node to the destination using walking distances, making sure that the resulting walking time does not exceed the maximum. We do this for every parking node and we get the best overall time. In case two paths have the same total time, we select the one with more walking time to be more economic.  <br /></td></tr>
<tr class="separator:aa7f4a2a19efe9c5718b1fe4164e4fe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a64a02bcebb9a65eec66909ee45245349" name="a64a02bcebb9a65eec66909ee45245349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a02bcebb9a65eec66909ee45245349">&#9670;&#160;</a></span>case1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void case1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>urban_map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the top-2 best routes to take from the source node to the destination on a specific mode </p>
<p>This function uses two dijkstras, the first one to compute the best route, and the second one executes after the intermediary nodes of the first were labelled, so that it does not include them in the dijkstra.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">urban_map</td><td>is a pointer to the <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a> graph containing locations and connections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function outputs to an output1.txt where the results can be seen.</dd></dl>
<p>@complexity Does two dijkstras each one with complexity <b>O((V+E)logV)</b> and also does two <a class="el" href="_planning_8cpp.html#a2d0b80f4eddcbcf2ab5534fa29bba6d5" title="Retrieves the shortest path from an origin to a destination in an UrbanMap.">getPath()</a> with complexity <b>O(V)</b> This results in a final complexity of <b>O((V+E)logV)</b> </p>

</div>
</div>
<a id="a2c0333fc34fc57bd91bd6f078843dd2f" name="a2c0333fc34fc57bd91bd6f078843dd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0333fc34fc57bd91bd6f078843dd2f">&#9670;&#160;</a></span>case2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void case2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>urban_map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the best route that avoids certain segments, locations(vertex) and may include a certain node in the path. Each node is deactivated using a boolean value <em>isVisited</em> and if that value is true the dijkstra won't include that node in the path. Same thing goes for the segments that also use a boolean value <em>isSelected</em>. </p>
<p>This function uses one dijkstra if there is no Node to include, or uses two dijkstras, one from the source to compute the distance to the node to include, and another starting from the included node to the destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">urban_map</td><td>is a pointer to the <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a> graph containing locations and connections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function outputs to an output2.txt where the results can be seen.</dd></dl>
<p>@complexity Does two dijkstras each one with complexity <b>O((V+E)logV)</b> or does only one dijkstra with the same complexity, and also uses function <a class="el" href="_planning_8cpp.html#a2d0b80f4eddcbcf2ab5534fa29bba6d5" title="Retrieves the shortest path from an origin to a destination in an UrbanMap.">getPath()</a> with complexity <b>O(V)</b> To deactivate the nodes it takes a traversal on a vector with ids <b>O(n)</b> To deactivate the segments it takes a traversal on a vector with pairs of ids and for the origin and destination it finds in the adjacency list the other node of the segment, so the complexity is <b>O(n*|E|)</b> This results in a final complexity of <b>O((V+E)logV), because the dijkstra dominates the complexity</b> </p>

</div>
</div>
<a id="aa7f4a2a19efe9c5718b1fe4164e4fe62" name="aa7f4a2a19efe9c5718b1fe4164e4fe62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f4a2a19efe9c5718b1fe4164e4fe62">&#9670;&#160;</a></span>case3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void case3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>urban_map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function combines both walking and driving. First we do a dijkstra from the source to a node in the parkingNodes vector of the graph, wich has all the ids of the nodes that have parking. Then we do a dijkstra from that parking node to the destination using walking distances, making sure that the resulting walking time does not exceed the maximum. We do this for every parking node and we get the best overall time. In case two paths have the same total time, we select the one with more walking time to be more economic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">urban_map</td><td>is a pointer to the <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a> graph containing locations and connections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function outputs to an output3.txt where the results can be seen.</dd></dl>
<p>@complexity Does two dijkstras each one with complexity <b>O((V+E)logV)</b> for each node in the parkingNodes vector of the graph, this results in <b>O(V(V+E)logV)</b>, and also uses function <a class="el" href="_planning_8cpp.html#a2d0b80f4eddcbcf2ab5534fa29bba6d5" title="Retrieves the shortest path from an origin to a destination in an UrbanMap.">getPath()</a> with complexity <b>O(V)</b> To deactivate the nodes it takes a traversal on a vector with ids <b>O(n)</b> To deactivate the segments it takes a traversal on a vector with pairs of ids and for the origin and destination it finds in the adjacency list the other node of the segment, so the complexity is <b>O(n*|E|)</b> This results in a final complexity of <b>O(V(V+E)logV)</b></p>
<p>When it comes to spacial complexity, since we compute each route to the parking node and then to the destination and we compute the path and save it on a vector, this results in @complexity <b>O(n)</b>. </p>

</div>
</div>
<a id="ae2e0e759108ef41e869dd46f4742151c" name="ae2e0e759108ef41e869dd46f4742151c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e0e759108ef41e869dd46f4742151c">&#9670;&#160;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dijkstra </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements Dijkstra's shortest path algorithm on an <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a>. </p>
<p>This function initializes all locations with a maximum distance and then applies Dijkstra's algorithm using a priority queue to find the shortest paths from the given origin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a> graph containing locations and connections. </td></tr>
    <tr><td class="paramname">origin</td><td>The index (1-based) of the starting location for Dijkstra's algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The algorithm uses a mutable priority queue to efficiently retrieve the vertex with the minimum distance, ensuring an optimal performance.</dd></dl>
<p>@complexity The time complexity is <b>O((V + E) log V)</b>, where:</p><ul>
<li>V is the number of locations (vertices) in the <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a>.</li>
<li>E is the number of connections (edges) between locations.</li>
<li>The <code>extractMin()</code> operation runs in <b>O(log V)</b>.</li>
<li>The relaxation step is performed <b>O(E)</b> times, each taking <b>O(log V)</b> in the worst case. </li>
</ul>

</div>
</div>
<a id="a2d0b80f4eddcbcf2ab5534fa29bba6d5" name="a2d0b80f4eddcbcf2ab5534fa29bba6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0b80f4eddcbcf2ab5534fa29bba6d5">&#9670;&#160;</a></span>getPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; getPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_urban_map.html">UrbanMap</a>&lt; std::string &gt; *</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the shortest path from an origin to a destination in an <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a>. </p>
<p>This function reconstructs the shortest path by backtracking from the destination to the origin using the <code><a class="el" href="_planning_8cpp.html#a2d0b80f4eddcbcf2ab5534fa29bba6d5" title="Retrieves the shortest path from an origin to a destination in an UrbanMap.">getPath()</a></code> pointers stored during the execution of Dijkstraâ€™s algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>Pointer to the <a class="el" href="class_urban_map.html" title="Represents an urban map as a graph structure.">UrbanMap</a> graph containing locations and connections. </td></tr>
    <tr><td class="paramname">origin</td><td>The name of the starting location. </td></tr>
    <tr><td class="paramname">dest</td><td>The name of the destination location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers representing the sequence of location IDs along the shortest path.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that Dijkstra's algorithm has already been executed, and the <code><a class="el" href="_planning_8cpp.html#a2d0b80f4eddcbcf2ab5534fa29bba6d5" title="Retrieves the shortest path from an origin to a destination in an UrbanMap.">getPath()</a></code> pointers are correctly set for each location.</dd></dl>
<p>@complexity The time complexity is <b>O(V)</b> in the worst case, where:</p><ul>
<li>Finding the destination vertex: <b>O(1)</b> (assuming efficient hashing or indexing).</li>
<li>Backtracking through the path: <b>O(V)</b> (in the worst case of a long path).</li>
<li>Reversing the result vector: <b>O(V)</b>.</li>
<li>Overall complexity: <b>O(V)</b>. </li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_b02e4219757ae4e3a0f1714873865bbf.html">classes</a></li><li class="navelem"><a class="el" href="_planning_8h.html">Planning.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
